date - выводит дату
Thu, Feb 28, 2019  8:04:17 PM

====================================================================

Попробуйте прямо сейчас посмотреть мануал программы ls,
набрав в терминале man ls. Для выхода из режима просмотра нажмите q,
для просмотра вперёд f (forward), назад — b (backward).

====================================================================================================================================================

say [-v voice] [-r rate] [-o outfile [audio format options] | -n name:port | -a device] [-f file | string ...]
Подобное описание есть практически у любой утилиты. Описания построены по одному и тому же принципу. Квадратные скобки обозначают опциональность [].
Например, опция -v опциональна, то же самое касается и любых других опций этой программы. Вертикальная черта | обозначает "или".
Причём именно исключающее или. Посмотрите на последний блок [-f file | string ...]. Он означает, что say может либо произносить текст из файла,
либо произносить строчку, переданную как аргумент, но не то и другое одновременно. Бывают и другие вариации описания способов вызова:
значение по умолчанию, выбор из конкретных элементов, отрицание.

И хотя мы разобрали не всё, с чем вам предстоит столкнуться, всё же остановимся, чтобы мозг окончательно не расплавился.
Главное, не стоит переживать, если вы не чувствуете, что всё это запомнили. Опции требуют практики и опытов, а не заучивания теории.
Теперь вы понимаете общие принципы и можете смотреть документацию, далее дело за экспериментами.

===================================================================================================================================================

Информация о любом файле или директории доступна по команде stat .comm.txt ( как "свойство" кликая правой кнопкой мыши )

Кроме регулярных файлов, в *nix существует ряд других:

Hard Link — дополнительное имя для уже существующего файла.
Symbolic link — символическая ссылка, такой файл похож на ярлык в Windows.
Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
Socket — специальный файл через который происходит взаимодействие между разными процессами операционной системы.
Программисты постоянно сталкиваются с сокетами в реальной жизни.

==========================================================================================================================================

cat - читать файл
head - читать первые 10 строк файла
tail - читать последние 10 строк файла
к нис сожно добавить флаг -n 50 (tail -n 50 .file.txt) xnj что бы прочитать 50 последних строк
tail -f path/to/file не просто выводит последние строчки файла, но ждёт появления новых.
Как только файл дописывается, tail сразу выводит на экран добавленные строки.

less предоставляет несколько десятков команд для перемещения по тексту и его поиску,
про большинство из них можно прочитать в соответствующем мануале. Здесь же затронем основные:

q — выход
f — вперёд на страницу
b — назад на страницу
если набрать /, затем начать вводить буквы и нажать Enter, то выполнится поиск введённого текста.
Перемещение по найденным совпадениям выполняется командой n (переход к следующему совпадению)
и командой N (переход к предыдущему совпадению).

=====================================================================================================

В примере выше grep нашёл 5 строк. Найденные строчки выводятся на экран в том же порядке,
в котором они встречаются в исходном файле. В некоторых ситуациях бывает важно увидеть не только саму строку, содержащую подстроку,
но и то, что находится вокруг неё. Количество выводимых соседних строк регулируется опциями -B, -A и -C.
Первая определяет количество отображаемых строк до искомой (-B, --before-context),
вторая — после (-A, --after-context), а третья — до и после одновременно (-C, --context).
Ниже пример использования -C со значением 1. Это значит, что для каждой найденной строки будет выведена
одна строка выше и одна строка ниже.

Иногда мы не знаем, в каком файле то, что мы ищем, но знаем директорию, в которой лежит этот файл. В такой ситуации нужно сделать два изменения:

Добавить опцию -R, которая говорит о том, что надо искать внутри директории (рекурсивно, то есть включая все поддиректории).
Указать путь до директории, а не файла.

==========================================================================================================

ls -la > output
Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл output.

$ grep alias .bash_profile > result
$ cat result
alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'
$ grep alias .bashrc | grep color

| — этот символ называется пайп, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса.
Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы,
могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно

$ cat .bashrc | grep alias | grep color

cat source | grep Dog | uniq | sort
Читается файл source
Входные данные грепаются по подстроке "Dog"
Убираются дубли (в исходном файле две одинаковых строки "Dog")
Входные данные сортируются и выводятся на экран

cat lanhuage | sort | grep -A 1 > solution

=============================================================================================================

# В текущей директории создаётся пустой файл
touch empty-file

Удаляется файл командой rm:
rm empty-file

В *nix системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению, которое выполняется командой mv
touch file
mv file renamed-file

Для копирования файлов и директорий используется утилита cp (copy). Её первый аргумент — имя источника (откуда), второй — имя приёмника (куда).
cp renamed-file renamed-file-copy
Для копирования директории нужно добавить флаг -r (recursive).

Все эти и последующие утилиты работают с файлами и директориями, расположенными в любом месте файловой системы.
Поэтому вы всегда можете передать любой путь: touch /tmp/tempfile.
Утилиты для работы с директориями частично отличаются. Создание директории выполняется командой mkdir.
mkdir my-dir

По умолчанию эта команда не создаёт вложенных директорий:
mkdir one/two/three
mkdir: cannot create directory ‘one/two/three’: No such file or directory

В такой ситуации придётся либо создавать каждую директорию отдельно,
либо воспользоваться флагом -p, который создаёт директории рекурсивно.
mkdir -p one/two/three

tree - Показывает дерево вложенности

Удаление директорий выполняется той же командой, что и удаление файлов, но без флагов оно выдаёт предупреждение:
rm my-dir/
rm: cannot remove 'my-dir/': Is a directory

Чтобы не было ошибки, нужно добавить флаг -r. Он включает режим рекурсивного (r - recursion) удаления содержимого директорий,
то есть идет просмотр всего что внутри во всех вложенных директориях и поддиректориях (до самого конца).
rm -r my-dir

Если внутри директории есть файлы, то команда rm начнёт задавать вопрос по каждому из них, нужно ли его удалять.
Если вы точно уверены, что удалить нужно всё, добавьте флаг -f. В таком случае rm удалит всю директорию без вопросов.
rm -rf one
==========================================================================================================================

Посмотреть историю можно и более простым способом, достаточно выполнить команду history.

$ history
    1  docke rps
    2  free -m
    3  docker ps
    4  docker exec -it 8678a6520641 bash
    5  ls
    6  exit
    7  docker ps
    8  docker exec -it 1209b6e5ce6b bash

    При необходимости историю всегда можно погрепать:

    $ history | grep export
      174  export HOME=/tmp
      183  history | grep export
    Последнее, и самое интересное — реверсивный поиск. Если нажать комбинацию Ctrl + r,
    то запустится специальный поиск по истории. Он ожидает ввода символов и сразу отображает ближайшую команду,
    в которой эти символы встречаются. Если найденное соответствие вас не устроило, то повторное нажатие Ctrl + r
    выберет следующее соответствие из истории.

======================================================================================================================

Взаимодействие с операционной системой всегда ведётся от какого-то конкретного пользователя,
созданного в системе. Команда whoami позволяет выяснить, кто же я такой:
$ whoami
kirill.m

=======================================================================================================================

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение.
Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и
остальных (Other) — тех, кто не попал в предыдущие две. Разберём на примере:

# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc

$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
Домашняя директория имеет другие права. Первое отличие — это d вместо - в самом начале. d говорит о том, что перед нами директория.
Права для владельца rwx, а для всех остальных r-x. Из этого описания видно, что кроме пользователя никто не может писать внутрь
домашней директории этого пользователя.

В литературе (статьях, книгах, мануалах) иногда используется другой способ описания прав доступа: 775.
Это не одно число, а три числа, каждое из которых представляет собой группу rwx для наших типов
пользователя в том же порядке: для владельца, входящих в группу и всех остальных. 0 — означает, что нет никаких
прав для данного типа пользователей.

drwxr-xr-x в числовой форме соответствует 755, а -rw-r--r-- — 644.

================================================================================================================================
